import { describe, it, expect, beforeAll, afterAll } from 'bun:test'
import { eventStore } from '../db/event-store-repository'
import { db } from '../db/index'
import { userProfiles } from '../db/schema'

// Generate a proper UUID for testing
function generateTestUUID(): string {
  return crypto.randomUUID()
}

// Helper to create a test user profile
async function createTestUser(name: string = 'Test User'): Promise<string> {
  const userId = generateTestUUID()
  const timestamp = Date.now()
  await db.insert(userProfiles).values({
    id: userId,
    email: `test${timestamp}${Math.random().toString(36).substr(2, 4)}@example.com`,
    name,
    avatarEmoji: 'üë§'
  })
  return userId
}

describe('Event Store Repository Tests', () => {
  describe('Game Creation', () => {
    it('should create game with host player', async () => {
      const hostUserId = await createTestUser('Test Host')
      const gameCode = `TEST${Math.random().toString(36).substr(2, 4).toUpperCase()}`
      
      const result = await eventStore.createGame({
        id: `test_game_${Date.now()}`,
        gameCode,
        hostUserId,
        hostPlayerName: 'Test Host',
        hostAvatarEmoji: 'üëë'
      })

      expect(result.game).toBeTruthy()
      expect(result.game.gameCode).toBe(gameCode)
      expect(result.game.currentPhase).toBe('lobby')
      expect(result.game.isActive).toBe(true)
      
      expect(result.hostPlayer).toBeTruthy()
      expect(result.hostPlayer.playerType).toBe('human')
      expect(result.hostPlayer.name).toBe('Test Host')
    })

    it('should prevent duplicate game codes', async () => {
      const gameCode = `DUP${Math.random().toString(36).substr(2, 4).toUpperCase()}`
      const hostUserId1 = await createTestUser('Host 1')
      const hostUserId2 = await createTestUser('Host 2')

      // Create first game
      await eventStore.createGame({
        id: `dup_game_1_${Date.now()}`,
        gameCode,
        hostUserId: hostUserId1,
        hostPlayerName: 'Host 1',
        hostAvatarEmoji: '1Ô∏è‚É£'
      })

      // Try to create second game with same code
      await expect(eventStore.createGame({
        id: `dup_game_2_${Date.now()}`,
        gameCode,
        hostUserId: hostUserId2,
        hostPlayerName: 'Host 2',
        hostAvatarEmoji: '2Ô∏è‚É£'
      })).rejects.toThrow()
    })

    it('should initialize event sequence for new game', async () => {
      const hostUserId = await createTestUser()
      const gameCode = `SEQ${Math.random().toString(36).substr(2, 4).toUpperCase()}`
      
      const result = await eventStore.createGame({
        id: `seq_game_${Date.now()}`,
        gameCode,
        hostUserId,
        hostPlayerName: 'Sequence Test Host',
        hostAvatarEmoji: 'üî¢'
      })

      const currentSequence = await eventStore.getCurrentSequence(result.game.id)
      expect(currentSequence).toBe(1) // Should have one initial event
    })
  })

  describe('Event Management', () => {
    let testGameId: string
    let testHostUserId: string

    beforeAll(async () => {
      testHostUserId = await createTestUser()
      const gameCode = `EVENT${Math.random().toString(36).substr(2, 3).toUpperCase()}`
      
      const result = await eventStore.createGame({
        id: `event_test_game_${Date.now()}`,
        gameCode,
        hostUserId: testHostUserId,
        hostPlayerName: 'Event Test Host',
        hostAvatarEmoji: 'üìù'
      })
      
      testGameId = result.game.id
    })

    it('should append events with atomic sequence generation', async () => {
      const eventData = {
        gameId: testGameId,
        playerId: 'test-player-id',
        eventType: 'ai_player_added' as const,
        data: {
          playerId: 'test-player-id',
          name: 'Test Bot',
          color: 'blue',
          joinOrder: 2,
          aiSettings: {
            difficulty: 'medium',
            personality: 'balanced',
            autoPlay: true,
            thinkingTimeMs: 2000
          }
        }
      }

      await eventStore.appendEvent(eventData)

      const events = await eventStore.getGameEvents(testGameId)
      const lastEvent = events[events.length - 1]
      
      expect(lastEvent.eventType).toBe('ai_player_added')
      expect(lastEvent.data.name).toBe('Test Bot')
      expect(lastEvent.sequenceNumber).toBeGreaterThan(0)
    })

    it('should maintain event ordering with concurrent appends', async () => {
      const concurrentEvents = []
      
      for (let i = 0; i < 5; i++) {
        concurrentEvents.push(
          eventStore.appendEvent({
            gameId: testGameId,
            playerId: `concurrent-player-${i}`,
            eventType: 'player_joined',
            data: {
              playerId: `concurrent-player-${i}`,
              userId: generateTestUUID(),
              playerType: 'human',
              name: `Concurrent Player ${i}`,
              color: 'red',
              joinOrder: i + 3,
              isHost: false
            }
          })
        )
      }

      await Promise.all(concurrentEvents)

      const events = await eventStore.getGameEvents(testGameId)
      
      // Verify sequence numbers are consecutive
      for (let i = 1; i < events.length; i++) {
        expect(events[i].sequenceNumber).toBe(events[i-1].sequenceNumber + 1)
      }
    })

    it('should filter events by sequence range', async () => {
      const currentSequence = await eventStore.getCurrentSequence(testGameId)
      
      // Get events from sequence 2 onwards
      const filteredEvents = await eventStore.getGameEvents(testGameId, {
        fromSequence: 2
      })

      expect(filteredEvents.length).toBe(currentSequence - 1)
      expect(filteredEvents[0].sequenceNumber).toBe(2)
    })

    it('should filter events by type', async () => {
      const playerEvents = await eventStore.getGameEvents(testGameId, {
        eventTypes: ['player_joined']
      })

      for (const event of playerEvents) {
        expect(event.eventType).toBe('player_joined')
      }
    })
  })

  describe('Game Lookup', () => {
    it('should find game by code', async () => {
      const hostUserId = await createTestUser()
      const gameCode = `LOOKUP${Math.random().toString(36).substr(2, 2).toUpperCase()}`
      
      const createResult = await eventStore.createGame({
        id: `lookup_game_${Date.now()}`,
        gameCode,
        hostUserId,
        hostPlayerName: 'Lookup Test Host',
        hostAvatarEmoji: 'üîç'
      })

      const foundGame = await eventStore.getGameByCode(gameCode)
      
      expect(foundGame).toBeTruthy()
      expect(foundGame?.id).toBe(createResult.game.id)
      expect(foundGame?.gameCode).toBe(gameCode)
    })

    it('should return null for non-existent game code', async () => {
      const nonExistentGame = await eventStore.getGameByCode('NONEXIST')
      expect(nonExistentGame).toBeNull()
    })

    it('should handle case-insensitive game code lookup', async () => {
      const hostUserId = await createTestUser()
      const gameCode = `CASE${Math.random().toString(36).substr(2, 2).toUpperCase()}`
      
      await eventStore.createGame({
        id: `case_game_${Date.now()}`,
        gameCode: gameCode.toUpperCase(),
        hostUserId,
        hostPlayerName: 'Case Test Host',
        hostAvatarEmoji: 'üî§'
      })

      const foundGame = await eventStore.getGameByCode(gameCode.toLowerCase())
      expect(foundGame).toBeTruthy()
    })
  })

  describe('Database Transactions', () => {
    it('should handle transaction rollback on error', async () => {
      const hostUserId = await createTestUser()
      const gameCode = `ROLLBACK${Math.random().toString(36).substr(2, 1).toUpperCase()}`
      
      try {
        // This should fail due to invalid UUID format
        await eventStore.createGame({
          id: `rollback_game_${Date.now()}`,
          gameCode,
          hostUserId: 'invalid-uuid-format',
          hostPlayerName: 'Rollback Test Host',
          hostAvatarEmoji: '‚Ü©Ô∏è'
        })
      } catch (error) {
        // Expected to fail
      }

      // Verify no partial data was committed
      const foundGame = await eventStore.getGameByCode(gameCode)
      expect(foundGame).toBeNull()
    })
  })

  describe('Sequence Generation Edge Cases', () => {
    it('should handle rapid sequence generation without gaps', async () => {
      const hostUserId = await createTestUser()
      const gameCode = `RAPID${Math.random().toString(36).substr(2, 2).toUpperCase()}`
      
      const result = await eventStore.createGame({
        id: `rapid_game_${Date.now()}`,
        gameCode,
        hostUserId,
        hostPlayerName: 'Rapid Test Host',
        hostAvatarEmoji: '‚ö°'
      })

      // Add many events rapidly
      const rapidPromises = []
      for (let i = 0; i < 10; i++) {
        rapidPromises.push(
          eventStore.appendEvent({
            gameId: result.game.id,
            playerId: `rapid-player-${i}`,
            eventType: 'settings_changed',
            data: {
              changes: { setting: `value-${i}` }
            }
          })
        )
      }

      await Promise.all(rapidPromises)

      const events = await eventStore.getGameEvents(result.game.id)
      
      // Should have 1 initial + 10 rapid events = 11 total
      expect(events.length).toBe(11)
      
      // Verify no sequence gaps
      for (let i = 0; i < events.length; i++) {
        expect(events[i].sequenceNumber).toBe(i + 1)
      }
    })

    it('should maintain sequence consistency across multiple games', async () => {
      const hostUserId1 = await createTestUser("Host 1")
      const hostUserId2 = generateTestUUID()
      
      const game1Result = await eventStore.createGame({
        id: `multi_game_1_${Date.now()}`,
        gameCode: `MULTI1${Math.random().toString(36).substr(2, 1).toUpperCase()}`,
        hostUserId: hostUserId1,
        hostPlayerName: 'Multi Host 1',
        hostAvatarEmoji: '1Ô∏è‚É£'
      })

      const game2Result = await eventStore.createGame({
        id: `multi_game_2_${Date.now()}`,
        gameCode: `MULTI2${Math.random().toString(36).substr(2, 1).toUpperCase()}`,
        hostUserId: hostUserId2,
        hostPlayerName: 'Multi Host 2',
        hostAvatarEmoji: '2Ô∏è‚É£'
      })

      // Add events to both games concurrently
      const mixedPromises = []
      for (let i = 0; i < 5; i++) {
        mixedPromises.push(
          eventStore.appendEvent({
            gameId: game1Result.game.id,
            eventType: 'settings_changed',
            data: { changes: { game1Setting: i } }
          })
        )
        mixedPromises.push(
          eventStore.appendEvent({
            gameId: game2Result.game.id,
            eventType: 'settings_changed',
            data: { changes: { game2Setting: i } }
          })
        )
      }

      await Promise.all(mixedPromises)

      // Verify each game has consistent sequence numbering
      const game1Events = await eventStore.getGameEvents(game1Result.game.id)
      const game2Events = await eventStore.getGameEvents(game2Result.game.id)

      for (let i = 0; i < game1Events.length; i++) {
        expect(game1Events[i].sequenceNumber).toBe(i + 1)
      }

      for (let i = 0; i < game2Events.length; i++) {
        expect(game2Events[i].sequenceNumber).toBe(i + 1)
      }
    })
  })

  describe('Error Handling', () => {
    it('should handle invalid event data gracefully', async () => {
      const hostUserId = await createTestUser()
      const gameCode = `ERROR${Math.random().toString(36).substr(2, 3).toUpperCase()}`
      
      const result = await eventStore.createGame({
        id: `error_game_${Date.now()}`,
        gameCode,
        hostUserId,
        hostPlayerName: 'Error Test Host',
        hostAvatarEmoji: '‚ùå'
      })

      // Try to append event with missing required data
      await expect(eventStore.appendEvent({
        gameId: result.game.id,
        eventType: 'player_joined',
        data: null as any // Invalid data
      })).rejects.toThrow()
    })

    it('should handle non-existent game ID in event append', async () => {
      await expect(eventStore.appendEvent({
        gameId: 'non-existent-game-id',
        eventType: 'player_joined',
        data: { test: 'data' }
      })).rejects.toThrow()
    })
  })
}) 